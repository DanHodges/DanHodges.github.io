---
title: The Tarmak method- my 2018 Resolution
description: The Tarmak method
header: The Tarmak method
categories: [code, life]
published: true
crosspost_to_medium: true
---
Several weeks ago I decided to learn and use the Colemak keyboard layout. The reason is obvious if you've ever stopped to think about how inefficient QWERTY is. So I dove in. I typed about 10 wpm for several hours then quit. Learning was too painful.

Later I discovered a transitional layout system called [Tarmak](https://forum.colemak.com/topic/1858-learn-colemak-in-steps-with-the-tarmak-layouts/). Tarmak is a series of 5 keyboard layouts. Each layout shifts 3 keys away from their default QWERTY location. The final layout is full Colemak. The typist is able to slowly learn Colemak without ever dropping below 30ish WPM by minimizing change.

I'm currently on layout 2 of 5. Just 6 keys have moved from their QWERTY location, but I already feel much more efficient, as letters E and T have shifted to the home row. I should be typing full Colemak by mid-march. If things go more slowly, however, I've lost nothing. It's a win-win.

I'll write a subsequent post about this process at a later date, but the revelation that's impressed me the most is that my initial approach to learning Colemak often mirrors my initial approach to learning new technologies- that desperately needs to change.

Over the past couple years I've created 'Hello, world' apps in no less than 2 dozen languages and frameworks. Like learning Colemak, I'll read about something new and shinny, something that's the king of the ___ hill, create the "hello, world" app for said shinny thing, then go to implement something meaningful only to give up 6 hours later because I can't figure out how to fetch data from a REST api (this is just an example- fetching JSON in Haskell is NOT the point).

There are dozens of things I want to play with in 2018- RxJS, Rust with WASM, Reason ML go name a few- but I'm going to try and resist playing with them. Outside of a deep dive into Scala (close to what I know with immediate day job application), I'm going to challenge myself _not_ to spend time on languages, frameworks, and tooling in favor investing in learning CS principles.

With [teachyourselfcs](https://teachyourselfcs.com/) as my road map, I intend to invest time into clarifying my understanding of CS principals and ideas, rather than specific implementations of those ideas. Hopefully, when it comes time to learn the new hotness, I'll have the mental furniture in place to accomplish that mission more effectively. More on that later.

-Dan



